<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java-Concurrent Introduction on Java-Concurrent</title>
    <link>https://hello-world-example.github.io/Java-Concurrent/</link>
    <description>Recent content in Java-Concurrent Introduction on Java-Concurrent</description>
    <generator>Hugo -- gohugo.io</generator>
    
	<atom:link href="https://hello-world-example.github.io/Java-Concurrent/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/_sidebar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/_sidebar/</guid>
      <description> java.lang  Thread ThreadLocal  sun.misc  Unsafe  java.util.concurrent.locks  LockSupport AbstractQueuedSynchronizer ReentrantLock [8]StampedLock  java.util.concurrent  ExecutorServiceâ™¨ Futureâ¿ ExecutorCompletionServiceâ¿ [7]ForkJoinâ™¨ [8]CompletableFutureâ¿ CountDownLatch ğŸ”’ SemaphoreğŸ”’ CyclicBarrierğŸ”’ [7] PhaserğŸ”’ BlockingQueueğŸ“ ArrayBlockingQueueğŸ“ LinkedBlockingQueueğŸ“ PriorityBlockingQueueğŸ“ SynchronousQueueğŸ“ ExchangerğŸ“  java.util.concurrent.atomic  AtomicLong [8]LongAdder   </description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.lang/Thread/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.lang/Thread/</guid>
      <description>Thread çº¿ç¨‹çŠ¶æ€  @see java.lang.Thread.State
  NEW è‡³ä»Šå°šæœªå¯åŠ¨çš„çº¿ç¨‹å¤„äºè¿™ç§çŠ¶æ€ï¼Œnew Thread RUNNABLE æ­£åœ¨ Java è™šæ‹Ÿæœºä¸­æ‰§è¡Œçš„çº¿ç¨‹å¤„äºè¿™ç§çŠ¶æ€ï¼Œnew Thread().start() BLOCKED å—é˜»å¡å¹¶ç­‰å¾…æŸä¸ªç›‘è§†å™¨é”çš„çº¿ç¨‹å¤„äºè¿™ç§çŠ¶æ€ï¼Œsynchronized(lock){} WAITING æ— é™æœŸåœ°ç­‰å¾…å¦ä¸€ä¸ªçº¿ç¨‹æ¥æ‰§è¡ŒæŸä¸€ç‰¹å®šæ“ä½œçš„çº¿ç¨‹å¤„äºè¿™ç§çŠ¶æ€ï¼Œsynchronized(lock){ lock.wait() } TIMED_WAITING ç­‰å¾…å¦ä¸€ä¸ªçº¿ç¨‹æ¥æ‰§è¡Œå–å†³äºæŒ‡å®šç­‰å¾…æ—¶é—´çš„æ“ä½œçš„çº¿ç¨‹å¤„äºè¿™ç§çŠ¶æ€ï¼Œï¼Œsynchronized(lock){ lock.wait(timeout) } ã€Thread.sleep(timeout) TERMINATED çº¿ç¨‹æ‰§è¡Œç»“æŸ  Methods ç®€ä»‹ thread.join() ç­‰å¾…çº¿ç¨‹æ‰§è¡Œå®Œæ¯•ï¼Œå†å‘ä¸‹æ‰§è¡Œï¼Œä¸ä¸»çº¿ç¨‹çš„å…³ç³»å˜æˆ ä¸²è¡Œæ‰§è¡Œã€‚
final Thread thread = new Thread(() -&amp;gt; System.out.println(System.currentTimeMillis())); thread.start(); // ç­‰å¾… thread çº¿ç¨‹æ‰§è¡Œå®Œæ¯•ï¼Œ å†æ‰§è¡Œä¸‹é¢çš„ä»£ç  thread.join(); System.out.println(&amp;#34;Main æ–¹æ³•ç»“æŸ&amp;#34;); Thread.yield() ä½¿ å½“å‰ çº¿ç¨‹ä»æ‰§è¡ŒçŠ¶æ€ å˜ä¸º å°±ç»ªçŠ¶æ€ï¼ŒCPU é‡æ–°ä»ä¼—å¤š å°±ç»ªçŠ¶æ€ çš„çº¿ç¨‹é‡Œé€‰æ‹©ï¼ŒåŒ…æ‹¬å½“å‰çº¿ç¨‹ã€‚
 ä¼˜å…ˆçº§é«˜çš„ä¸æ˜¯ä¸€å®šè¢«æ‰§è¡Œ å½“å‰çº¿ç¨‹ä¸æ˜¯å·²ç»ä¸è¢«æ‰§è¡Œ æ‰€æœ‰ å°±ç»ªçŠ¶æ€çš„çº¿ç¨‹ï¼Œéƒ½æœ‰å¯èƒ½è¢«æ‰§è¡Œ æƒ…å†µå–å†³äº CPU çš„é€‰æ‹©ï¼Œç»“æœæ˜¯éšæœºçš„  thread.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.lang/ThreadLocal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.lang/ThreadLocal/</guid>
      <description>ThreadLoad ç®€ä»‹  ThreadLocal å®ä¾‹é€šå¸¸æ˜¯ç±»ä¸­çš„ private static final å­—æ®µ æ•°æ® æ¯ä¸ªçº¿ç¨‹ç»´æŠ¤ä¸€ä»½ï¼Œé€šè¿‡éš”ç¦»ã€é¿å…ç«äº‰ çº¿ç¨‹æ± ä¸­æ¯ä¸ªçº¿ç¨‹æ˜¯å…±äº«çš„ï¼Œä½¿ç”¨å®Œéœ€è¦æ¸…é™¤ï¼Œå¦åˆ™ä¸‹æ¬¡çš„çº¿ç¨‹ä½¿ç”¨è€…ä¼šä½¿ç”¨åˆ°ä¸Šæ¬¡ä½¿ç”¨è€…è®¾ç½®çš„æ•°æ® ä¸ªäººæ„Ÿè§‰ æ•°æ®æ˜¯ç”± Thread è‡ªå·±ç»´æŠ¤çš„ï¼ŒThreadLocal åªæ˜¯ç»™æˆ‘ä»¬æä¾›äº†æ“ä½œ Thread å†…éƒ¨å˜é‡çš„å·¥å…·  ThreadLocal ä»£ç ç‰‡æ®µ ThreadLocalMap getMap(Thread t) { return t.threadLocals; } // key: ThreadLocal ; vlaue: æ˜¯å­˜å‚¨çš„æ•°æ® void createMap(Thread t, T firstValue) { t.threadLocals = new ThreadLocalMap(this, firstValue); } public T get() { // native æ–¹æ³•ï¼Œè¿”å›å½“å‰çº¿ç¨‹å¯¹è±¡  Thread t = Thread.currentThread(); // è·å–çº¿ç¨‹ï¼ˆThreadï¼‰çš„ threadLocals å˜é‡ï¼Œç±»å‹æ˜¯ ThreadLocal.ThreadLocalMap  ThreadLocalMap map = getMap(t); // åˆšåˆ›å»ºå‡ºæ¥çš„ çº¿ç¨‹ï¼ˆThreadï¼‰ç»´æŠ¤çš„ threadLocals å˜é‡æ˜¯ null  if (map !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/ArrayBlockingQueue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/ArrayBlockingQueue/</guid>
      <description>ArrayBlockingQueue  @see BlockingQueue
  ArrayBlockingQueue æ˜¯ BlockingQueue çš„ä¸€ä¸ªåŸºäºæ•°ç»„çš„å®ç° åŸºäº ReentrantLock çš„ await å’Œ signal é€šçŸ¥æœºåˆ¶ å®ç°é˜»å¡ æ“ä½œé˜Ÿåˆ—æ•°æ®çš„æ—¶å€™ å¹¶ä¸åƒ ArrayList ä¸€æ ·ï¼Œéœ€è¦æ‰©å®¹ æˆ– æ•°æ®å¹³ç§»å¸¦æ¥çš„æ€§èƒ½æŸè€— ä»…ä»…ä¾é å¹³ç§» takeIndex / putIndex è¯»å†™åæ ‡  å®ç°åŸç† ArrayBlockingQueue æ„é€  // é˜Ÿåˆ—å…ƒç´  final Object[] items; // è¯»å–åæ ‡ int takeIndex; // å†™å…¥åæ ‡ int putIndex; // å½“å‰æ•°æ®ä¸ªæ•° int count; public ArrayBlockingQueue(int capacity, boolean fair) { if (capacity &amp;lt;= 0) throw new IllegalArgumentException(); this.items = new Object[capacity]; // åŸºäº Lock çš„ await å’Œ signal é€šçŸ¥æœºåˆ¶  lock = new ReentrantLock(fair); // å®ä¾‹åŒ–äº†ä¸¤ä¸ª Condition é˜Ÿåˆ—ï¼Œç”¨äºåŒºåˆ† è·å– å’Œ æ·»åŠ   // å”¤é†’çš„æ—¶å€™å¯ä»¥å”¤é†’ æŒ‡å®šç±»å‹çš„æ“ä½œ  notEmpty = lock.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/atomic/AtomicLong/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/atomic/AtomicLong/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/atomic/LongAdder/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/atomic/LongAdder/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/BlockingQueue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/BlockingQueue/</guid>
      <description> BlockingQueue BlockingQueue ä¸æ¥å— null ï¼Œè¯•å›¾ addã€put æˆ– offer ä¸€ä¸ª null å…ƒç´ æ—¶ï¼Œä¼šæŠ›å‡º NullPointerExceptionï¼Œnull è¢«ç”¨ä½œæŒ‡ç¤º poll æ“ä½œå¤±è´¥çš„è­¦æˆ’å€¼ã€‚
BlockingQueue å››ç§å½¢çš„æ“ä½œ
 åœ¨æ“ä½œå¯ä»¥æˆåŠŸå‰ï¼Œæ— é™æœŸåœ°é˜»å¡å½“å‰çº¿ç¨‹ æŠ›å‡ºä¸€ä¸ªå¼‚å¸¸ è¿”å›ä¸€ä¸ªç‰¹æ®Šå€¼ï¼ˆnull æˆ– falseï¼Œå…·ä½“å–å†³äºæ“ä½œï¼‰ é˜»å¡æŒ‡å®šçš„æ—¶é—´      é˜»å¡ æŠ›å‡ºå¼‚å¸¸ ç‰¹æ®Šå€¼ è¶…æ—¶     æ’å…¥ put add(e) IllegalArgumentException offer(e) offer(e,time,unit)   ç§»é™¤ take remove NoSuchElementException poll() poll(time, unit)   æ£€æŸ¥
è·å–ä½†ä¸ç§»é™¤ - element NoSuchElementException peek -    é˜»å¡é˜Ÿåˆ—çš„å®ç°  ArrayBlockingQueue åŸºäºæ•°ç»„çš„ é˜»å¡é˜Ÿåˆ— LinkedBlockingQueue åŸºäºé“¾è¡¨çš„ é˜»å¡å¯¹è” SynchronousQueue æ²¡æœ‰é•¿åº¦ çš„é˜»å¡é˜Ÿåˆ— DelayQueue å»¶æ—¶é˜Ÿåˆ— PriorityBlockingQueue æœ‰æƒé‡çš„ é˜»å¡é˜Ÿåˆ—  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/CompletableFuture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/CompletableFuture/</guid>
      <description>CompletableFuture Java8 å¸¦æ¥äº† CompletableFutureï¼Œä¸€ä¸ª Future çš„æ‰©å±•ç±»ï¼Œæå¤§ä¸°å¯Œäº† Future çš„åŠŸèƒ½ï¼Œå¸®åŠ©æˆ‘ä»¬ç®€åŒ–å¼‚æ­¥ç¼–ç¨‹çš„å¤æ‚æ€§ï¼Œå¹¶ä¸”æä¾›äº†å‡½æ•°å¼ç¼–ç¨‹çš„èƒ½åŠ›ã€‚
æ„é€ æ–¹å¼ API    å¸¸ç”¨æ–¹æ³• æè¿°     supplyAsync(Supplier&amp;lt;U&amp;gt;) æœ‰è¿”å›å€¼çš„ä»»åŠ¡ã€‚
å¤šæ ¸ä¸‹é»˜è®¤ä½¿ç”¨ ForkJoinPoolçº¿ç¨‹æ± ï¼Œä¹Ÿå¯ä»¥è‡ªè¡Œæ„é€    runAsync(Runnable) æ— è¿”å›å€¼çš„ä»»åŠ¡ã€‚
å¤šæ ¸ä¸‹é»˜è®¤ä½¿ç”¨ ForkJoinPoolçº¿ç¨‹æ± ï¼Œä¹Ÿå¯ä»¥è‡ªè¡Œæ„é€        allOf(CompletableFuture&amp;lt;?&amp;gt;...) æ‰€æœ‰ CompletableFuture å®Œæˆä»£è¡¨å®Œæˆ   anyOf(CompletableFuture&amp;lt;?&amp;gt;...) ä»»æ„ä¸€ä¸ª CompletableFuture å®Œæˆä»£è¡¨å®Œæˆ       completedFuture(U value) ç›´æ¥è·å– å®ŒæˆçŠ¶æ€ çš„ CompletableFuture    ä»»åŠ¡å…³ç³» API æ¦‚è¿°  thenAccept ï¼š ä»»åŠ¡æ‰§è¡Œå®Œçš„ å›è°ƒå‡½æ•°ï¼Œå‚æ•°æ˜¯ä»»åŠ¡çš„æ‰§è¡Œç»“æœ  thenAcceptBothï¼š ä¸¤ä¸ªä»»åŠ¡åŒæ—¶æ‰§è¡Œå®Œçš„ å›è°ƒå‡½æ•°ï¼ŒthenAccept æ˜¯å•ä¸ªä»»åŠ¡ acceptEitherï¼š ç¬¬ä¸€ä¸ª æˆ– ç¬¬äºŒä¸ª ä»»åŠ¡æ‰§è¡Œå®Œçš„ å›è°ƒå‡½æ•°  thenRunï¼šä»»åŠ¡æ‰§è¡Œå®Œçš„ å›è°ƒå‡½æ•°ï¼Œæ¥æ”¶ Runnableï¼Œæ— æ³•è·å–è¿”è¿”å›ç»“æœ thenApplyï¼š å¯¹ä¸Šä¸€ä¸ªä»»åŠ¡çš„ç»“æœè¿›è¡Œçš„ä¸­é—´è®¡ç®—ï¼Œè¿”å›å€¼ä¼ å¾€ä¸‹ä¼ é€’  applyToEitherï¼šç¬¬ä¸€ä¸ª æˆ– ç¬¬äºŒä¸ª ä»»åŠ¡æ‰§è¡Œå®Œçš„ å›è°ƒå‡½æ•°ï¼Œè¿”å›å€¼ä¼ å¾€ä¸‹ä¼ é€’  thenComposeï¼š ä¸ thenApply ä½œç”¨ç±»ä¼¼ï¼Œä¸è¿‡è¿”å›å€¼è¢« CompletableFuture åŒ…è£… thenCombineï¼š ä¸ thenAcceptBoth ç±»ä¼¼ï¼Œä¸è¿‡æœ‰æœ‰è¿”å›å€¼  thenAccept(Consumer) / thenRun(Runnable) final CompletableFuture&amp;lt;Integer&amp;gt; completableFuture = CompletableFuture.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/CountDownLatch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/CountDownLatch/</guid>
      <description>CountDownLatch CountDownLatch åŸºäº AQS åŒæ­¥æ¡†æ¶ï¼Œå…è®¸ä¸€ä¸ªæˆ–å¤šä¸ªçº¿ç¨‹ await ç­‰å¾…ï¼Œç›´åˆ°æŒ‡å®šæ•°é‡(count) çš„æ“ä½œå®Œæˆ(countDown)
åˆå§‹ CountDownLatch æ—¶ï¼Œä¼šç»™å®š countï¼Œè°ƒç”¨ await æ–¹æ³•æ—¶ä¼šé˜»å¡å½“å‰çº¿ç¨‹ï¼Œç›´åˆ° count å‡å°åˆ° 0ï¼ŒcountDown ä¼šä½¿ count å‡ 1ï¼Œè¯¥åŒæ­¥å™¨ä¸èƒ½è¢«é‡ç½®ã€‚
å¦‚ä½•ä½¿ç”¨ ä¸»çº¿ç¨‹ ç­‰å¾… å­çº¿ç¨‹ int count = 3; CountDownLatch countDownLatch = new CountDownLatch(count); for (int i = 0; i &amp;lt; 3; i++) { int finalI = i; new Thread(() -&amp;gt; { ThreadUtil.sleep(finalI, TimeUnit.SECONDS); Tool.println(Thread.currentThread().getName() + &amp;#34; å®Œæˆ&amp;#34;); // count - 1  countDownLatch.countDown(); }).start(); } Tool.println(&amp;#34;ç­‰å¾… &amp;#34; + count + &amp;#34;ä¸ª ä»»åŠ¡å®Œæˆ&amp;#34;); // é˜»å¡å½“å‰çº¿ç¨‹ countDownLatch.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/CyclicBarrier/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/CyclicBarrier/</guid>
      <description>CyclicBarrier å¦‚ä½•ä½¿ç”¨ CyclicBarrier cyclicBarrier = new CyclicBarrier(3); // éšæœºä¼‘æ¯ä¸€æ®µæ—¶é—´ Runnable work = () -&amp;gt; { final int sleep = Math.abs(new Random().nextInt() % 10); Tool.println(&amp;#34;sleep &amp;#34; + sleep); ThreadUtil.sleep(sleep, TimeUnit.SECONDS); }; // è°ƒç”¨ barrier.await() Consumer&amp;lt;CyclicBarrier&amp;gt; await = (CyclicBarrier barrier) -&amp;gt; { try { barrier.await(); } catch (Exception e) { e.printStackTrace(); } }; final Runnable runnable = () -&amp;gt; { work.run(); await.accept(cyclicBarrier); // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å‡†å¤‡å¥½  Tool.println(&amp;#34;A &amp;#34;); work.run(); await.accept(cyclicBarrier); // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å‡†å¤‡å¥½  Tool.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/Exchanger/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/Exchanger/</guid>
      <description>Exchanger Exchanger è·Ÿ SynchronousQueue æœ‰ç‚¹ç±»ä¼¼ï¼Œéƒ½æœ‰ç‚¹ç±»ä¼¼äºçº¿ç¨‹é—´é€šè®¯
 Exchanger åœ¨å‘é€çš„æ—¶å€™åŒæ—¶èƒ½å¤Ÿæ¥æ”¶ SynchronousQueue ä¸€ä¸ªå‘é€ä¸€ä¸ªæ¥æ”¶ï¼Œåˆ›å»ºä¸¤ä¸ª SynchronousQueue æ¥ä¼ é€’æ•°æ®å¥½åƒåŒæ ·å¯ä»¥è¾¾åˆ° Exchanger çš„æ•ˆæœ  å¦‚ä½•ä½¿ç”¨ Exchanger&amp;lt;Integer&amp;gt; exchanger = new Exchanger&amp;lt;&amp;gt;(); Runnable runnable = () -&amp;gt; { for (; ; ) { final int newData = Math.abs(new Random().nextInt() % 100); Integer oldData = 0; try { Tool.println(&amp;#34;èµ°ä½  â†’ &amp;#34; + newData); oldData = exchanger.exchange(newData); Tool.println(&amp;#34;â† æ”¶åˆ° &amp;#34; + oldData); } catch (InterruptedException e) { e.printStackTrace(); } ThreadUtil.sleep(newData * 10); if (newData &amp;lt; 30 || oldData &amp;lt; 30) { break; } } }; new Thread(runnable).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/ExecutorCompletionService/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/ExecutorCompletionService/</guid>
      <description>ExecutorCompletionService ExecutorCompletionService æ˜¯ä¸€ä¸ªè·å–å¼‚æ­¥ä»»åŠ¡ç»“æœçš„å·¥å…·ç±»ã€‚
å°è£…äº† Executor å’Œ BlockingQueueï¼ŒæŠŠå·²ç»å®Œæˆçš„ä»»åŠ¡æ”¾å…¥é˜Ÿåˆ—ï¼Œæä¾›ä»é˜Ÿåˆ—ä¸­è·å–ç»“æœçš„æ–¹æ³• take / pollã€‚
æºç æ‘˜å½• public class ExecutorCompletionService&amp;lt;V&amp;gt; implements CompletionService&amp;lt;V&amp;gt; { private final Executor executor; private final BlockingQueue&amp;lt;Future&amp;lt;V&amp;gt;&amp;gt; completionQueue; private class QueueingFuture extends FutureTask&amp;lt;Void&amp;gt; { private final Future&amp;lt;V&amp;gt; task; QueueingFuture(RunnableFuture&amp;lt;V&amp;gt; task) { super(task, null); this.task = task; } // â¤ FutureTask æ‰§è¡Œå®Œæˆåï¼Œä¼šå›è°ƒ Done æ–¹æ³•  protected void done() { // åŠ å…¥é˜Ÿåˆ—  completionQueue.add(task); } } public Future&amp;lt;V&amp;gt; take() throws InterruptedException { return completionQueue.take(); } public Future&amp;lt;V&amp;gt; poll() { return completionQueue.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/ExecutorService/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/ExecutorService/</guid>
      <description>ExecutorService   java.util.concurrent.ExecutorService java.util.concurrent.ThreadPoolExecutor   ç»§æ‰¿å…³ç³» - Executor (java.util.concurrent) - â¤5â¤ ExecutorService (java.util.concurrent) - AbstractExecutorService (java.util.concurrent) - â¤5â¤ ThreadPoolExecutor (java.util.concurrent) - â¤5â¤ ScheduledThreadPoolExecutor (java.util.concurrent) - â¤7â¤ ForkJoinPool (java.util.concurrent) - ScheduledExecutorService (java.util.concurrent) - ScheduledThreadPoolExecutor (java.util.concurrent)  ThreadPoolExecutor ThreadPoolExecutor çš„æ„é€ å‚æ•°å¦‚ä¸‹
/** * @param corePoolSize æœ€å°çº¿ç¨‹æ•° * @param maximumPoolSize æœ€å¤§çº¿ç¨‹æ•° * @param keepAliveTime corePoolSize åˆ° maximumPoolSize çº¿ç¨‹çš„ç©ºé—²æ—¶é—´ï¼Œè¶…è¿‡è¯¥æ—¶é—´ä¼šè¢«é‡Šæ”¾ * @param unit å‚æ•° keepAliveTime çš„å•ä½ * @param workQueue åœ¨ä»»åŠ¡æ‰§è¡Œä¹‹å‰ä¿å­˜è¿›è¯¥é˜Ÿåˆ— * @param threadFactory çº¿ç¨‹å·¥å‚ï¼Œä¸»è¦ç»™çº¿ç¨‹å™¨åå­—ï¼Œâ¤ é»˜è®¤ï¼šExecutors.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/ForkJoin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/ForkJoin/</guid>
      <description>ForkJoin ForkJoin æ˜¯ä¸€ä¸ª åŸºäºåˆ†è€Œæ²»ä¹‹ç®—æ³•ï¼Œ æŠŠå¤§ä»»åŠ¡åˆ†å‰²æˆè‹¥å¹²ä¸ªå°ä»»åŠ¡ï¼Œæœ€ç»ˆæ±‡æ€»æ¯ä¸ªå°ä»»åŠ¡ç»“æœåï¼Œå¾—åˆ°å¤§ä»»åŠ¡ç»“æœçš„æ¡†æ¶ã€‚æ¡†æ¶åŸºäºä»¥ä¸‹ä¸¤ç§æ“ä½œï¼š
 fork æ“ä½œï¼šæŠŠä»»åŠ¡åˆ†æˆæ›´å°çš„ä»»åŠ¡ï¼Œä½¿ç”¨è¿™ä¸ªæ¡†æ¶æ‰§è¡Œå®ƒä»¬ join æ“ä½œï¼šç­‰å¾…åˆ›å»ºçš„ä»»åŠ¡çš„è®¡ç®—ç»“æŸ  ä¸ Executor çš„åŒºåˆ«  Executor æ˜¯æ‰€æœ‰å·¥ä½œçº¿ç¨‹å…¬ç”¨ä¸€ä¸ªä»»åŠ¡é˜Ÿåˆ—ï¼Œæ‰€æœ‰çš„çº¿ç¨‹æ¶ˆè´¹ä¸€ä¸ªä»»åŠ¡é˜Ÿåˆ—é‡Œé¢çš„ä»»åŠ¡ ForkJoin æ˜¯ æ¯ä¸ªçº¿ç¨‹éƒ½æœ‰ä¸€ä¸ªä»»åŠ¡å¯¹è±¡ï¼Œæ¯ä¸ªçº¿ç¨‹æ¶ˆè´¹å„è‡ªä»»åŠ¡é˜Ÿåˆ—çš„ä»»åŠ¡   è¿™æ ·çš„è¯ï¼Œ ForkJoin å¯èƒ½ä¼šå¯¼è‡´ä¸€ä¸ªé—®é¢˜ï¼Œå‡å¦‚æœ‰äº›ä»»åŠ¡é˜Ÿåˆ—æ—©æ—©è¢«æ¶ˆè´¹å®Œäº†ï¼Œåˆ™è¯¥é˜Ÿåˆ—å¯¹åº”çš„çº¿ç¨‹å°±é—²ç½®äº† Executor åˆ™ä¸ä¼šå‡ºç°è¯¥é—®é¢˜ï¼Œå› ä¸ºåªæœ‰ä¸€ä¸ªé˜Ÿåˆ—ï¼Œå½“çº¿ç¨‹æ‰§è¡Œå®Œä¸€ä¸ªä»»åŠ¡åï¼Œé‡æ–°ä»é˜Ÿåˆ—ä¸­è·å–ä»»åŠ¡ï¼Œç›´åˆ°æ‰€æœ‰çš„ä»»åŠ¡æ‰§è¡Œæ¢æ‰ä¼šé—²ç½®   ForkJoin ä¸ºäº†è§£å†³ä»»åŠ¡é˜Ÿåˆ—æ¶ˆè´¹é€Ÿåº¦ä¸ä¸€è‡´å¯¼è‡´çš„é—²ç½®é—®é¢˜ï¼Œå½“ä¸€ä¸ªä»»åŠ¡é˜Ÿåˆ—æ‰§è¡Œå®Œä¹‹åï¼Œå°±å»å…¶ä»–çº¿ç¨‹çš„é˜Ÿåˆ—é‡Œçªƒå–ä¸€ä¸ªä»»åŠ¡æ¥æ‰§è¡Œï¼Œè¿˜ç»™è¿™ä¸ªè¡Œä¸ºèµ·äº†ä¸€ä¸ªé«˜å¤§ä¸Šçš„åå­—ï¼šå·¥ä½œçªƒå–ï¼ˆwork-stealingï¼‰ç®—æ³•ã€‚JDK 1.8 å¯ä»¥ç®€å•çš„é€šè¿‡ ExecutorService executor = Executors.newWorkStealingPool(4) è·å–æ”¹ç±»å‹çš„ Executor è§£å†³äº†çº¿ç¨‹é—²ç½®é—®é¢˜ï¼Œ Executor å’Œ ForkJoin çš„çº¿ç¨‹éƒ½å¯è¾¾åˆ°æ»¡è´Ÿè·è¿è¡Œäº†ï¼Œè¿™æ—¶å€™çš„åŒºåˆ«åœ¨äºä¸¤è€…å¯¹æ•°æ®çš„ç«äº‰çŠ¶æ€ä¸ä¸€æ ·  Executor å§‹ç»ˆéƒ½æ˜¯æ‰€æœ‰çš„çº¿ç¨‹ç«äº‰ä¸€ä¸ªé˜Ÿåˆ—çš„æ•°æ® ForkJoin åªæœ‰åœ¨ â€œçªƒå–â€ å…¶ä»–çº¿ç¨‹ä»»åŠ¡é˜Ÿé‡Œçš„æœ€åä¸€æ¡æ•°æ®çš„æ—¶å€™æ‰äº§ç”Ÿç«äº‰   æ ¸å¿ƒç±»  ForkJoinPoolï¼šå®ƒå®ç° ExecutorService æ¥å£ å’Œ work-stealing ç®—æ³•ï¼Œç®¡ç†å·¥ä½œçº¿ç¨‹å’Œæä¾›å…³äºä»»åŠ¡çš„çŠ¶æ€å’Œæ‰§è¡Œçš„ä¿¡æ¯ ForkJoinTaskï¼š å®ƒæ˜¯æ˜¯åœ¨ ForkJoinPool ä¸­æ‰§è¡Œçš„ä»»åŠ¡çš„åŸºç±»ï¼Œæä¾›åœ¨ä»»åŠ¡ä¸­æ‰§è¡Œ fork() å’Œ join() æ“ä½œçš„æœºåˆ¶ã€‚é€šå¸¸ï¼Œ ä¸ºäº†å®ç°ä½ çš„ Fork/Join ä»»åŠ¡ï¼Œéœ€è¦å®ç° ForkJoinTask çš„å­ç±»  RecursiveAction å¤„ç†æ²¡æœ‰è¿”å›å€¼çš„ä»»åŠ¡ RecursiveTask å¤„ç†æœ‰è¿”å›å€¼çš„ä»»åŠ¡   ç¼–ç¨‹æµç¨‹ ä¸€ä¸ªä½¿ç”¨ ForkJoin æ¡†æ¶ç´¯åŠ çš„ç¤ºä¾‹</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/Future/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/Future/</guid>
      <description>Future  en java.util.concurrent.Future
zh java.util.concurrent.Future
 Future æ¥å£ Future æ¥å£æ˜¯å¯¹å¼‚æ­¥è¡Œä¸ºçš„æŠ½è±¡ï¼Œç”¨æ¥è¡¨ç¤ºå¼‚æ­¥è®¡ç®—çš„ç»“æœï¼Œæ¥å£æ¯”è¾ƒç®€å•ï¼Œå¦‚ä¸‹ï¼š
public interface Future&amp;lt;V&amp;gt; { // ç­‰å¾…ä»»åŠ¡ç»“æŸï¼Œè·å–ç»“æœ  V get() throws InterruptedException, ExecutionException; // è·å–ç»“æœï¼Œè®¾ç½®è¶…æ—¶æ—¶é—´  V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; // å–æ¶ˆä»»åŠ¡çš„æ‰§è¡Œ  boolean cancel(boolean mayInterruptIfRunning); // æ­£å¸¸å®Œæˆå‰å–æ¶ˆï¼Œè¿”å› true  boolean isCancelled(); // ä»»åŠ¡æ­£å¸¸ç»ˆæ­¢ã€å¼‚å¸¸æˆ–å–æ¶ˆï¼Œè¿”å›true  boolean isDone(); } ç»§æ‰¿å…³ç³»  Future (java.util.concurrent)  RunnableFuture (java.util.concurrent) extends Runnable  FutureTask (java.util.concurrent)  ForkJoinTask (java.util.concurrent) CompletableFuture (java.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/LinkedBlockingQueue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/LinkedBlockingQueue/</guid>
      <description> LinkedBlockingQueue  @see ArrayBlockingQueue
  LinkedBlockingQueue æ˜¯ BlockingQueue çš„ä¸€ä¸ªåŸºäºé“¾è¡¨çš„å®ç° åŸºäº ReentrantLock çš„ await å’Œ signal é€šçŸ¥æœºåˆ¶ å®ç°é˜»å¡ï¼Œä¸€ä¸ªåŒºåˆ«æ˜¯  LinkedBlockingQueue çš„å¢åˆ æ“ä½œåˆ†è¾¨ä½¿ç”¨ ä¸¤ä¸ªé”ï¼Œå¢åˆ äº’ä¸å½±å“ ArrayBlockingQueue ä½¿ç”¨ä¸€ä¸ªé”ï¼Œå¢åˆ çš„æ—¶å€™æœ‰ç«æ€æ¡ä»¶  é˜»å¡åŸç†å‡ ä¹ä¸ ArrayBlockingQueue ä¸€æ ·ï¼Œä¸»è¦å…³æ³¨è¾¹ç•Œæ¡ä»¶ å…¥é˜Ÿå’Œå‡ºé˜Ÿæ—¶çš„æ“ä½œä¸€ä¸ªé“¾è¡¨èŠ‚ç‚¹çš„å¢åˆ ï¼Œä¸€ä¸ªæ˜¯è¯»å†™ä¸‹æ ‡çš„å¹³ç§»  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/locks/AbstractQueuedSynchronizer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/locks/AbstractQueuedSynchronizer/</guid>
      <description>AQS ~ AbstractQueuedSynchronizer  javadocï¼š java.util.concurrent.locks.AbstractQueuedSynchronizer
 AbstractQueuedSynchronizer ç›´è¯‘è¿‡æ¥å°±æ˜¯ æŠ½è±¡æ’é˜ŸåŒæ­¥å™¨ï¼Œç®€ç§° AQSï¼Œå¯ä»¥æŠŠå®ƒè®¤ä¸ºæ˜¯è§„å®šå¤šçº¿ç¨‹è®¿é—®å…±äº«èµ„æºçš„æ¡†æ¶ã€‚
ç»§æ‰¿å…³ç³» ä»ä»¥ä¸‹éƒ¨åˆ†ç»§æ‰¿å…³ç³»ä¸­å¯ä»¥çœ‹å‡ºï¼Œj.u.c åŒ…ä¸‹é¢çš„ä¸€äº›æ ¸å¿ƒç±»ï¼Œéƒ½ç»§æ‰¿è‡ª AQSã€‚
 AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer  Sync in ReentrantLock (java.util.concurrent.locks) __ FairSync in ReentrantLock (java.util.concurrent.locks) __ NonfairSync in ReentrantLock (java.util.concurrent.locks) Sync in ReentrantReadWriteLock (java.util.concurrent.locks) Sync in CountDownLatch (java.util.concurrent) Sync in Semaphore (java.util.concurrent) Worker in ThreadPoolExecutor (java.util.concurrent)   é˜Ÿåˆ— Node ç»“æ„ AQS ä¸»è¦é€šè¿‡å†…ç½®çš„ FIFOé˜Ÿåˆ— æ¥å®Œæˆèµ„æºè·å–çº¿ç¨‹çš„æ’é˜Ÿå·¥ä½œã€‚
static final class Node { // å…±äº«æ¨¡å¼  static final Node SHARED = new Node(); // ç‹¬å æ¨¡å¼  static final Node EXCLUSIVE = null; /** å–æ¶ˆçŠ¶æ€ï¼Œè¯¥çŠ¶æ€æ˜¯æœ€ç»ˆçŠ¶æ€ï¼Œä¸ä¼šè¢«æ”¹å˜ï¼Œ */ static final int CANCELLED = 1; // åç»§èŠ‚ç‚¹ è¢« park éœ€è¦ unparkï¼ˆè¢«å”¤é†’ï¼‰  // åç»§èŠ‚ç‚¹å¦‚æœå‘ç° å‰é©±èŠ‚ç‚¹æ˜¯ SIGNALï¼Œpark è‡ªå·±  static final int SIGNAL = -1; /** è¡¨åå½“å‰çº¿ç¨‹æ­£åœ¨ç­‰å¾… conditionï¼Œä¹Ÿå°±æ˜¯åœ¨ condition é˜Ÿåˆ—ä¸­ */ static final int CONDITION = -2; // SIGNAL ä¸€èˆ¬ç”¨æ¥ç‹¬å æœ«å®ç°ï¼ŒPROPAGATE ç”¨åœ¨ å…±äº«æ¨¡å¼ä¸‹ï¼Œè¯¥çŠ¶æ€çº¿ç¨‹ä¸ä¼š parkï¼Œå¯ä»¥è·å–åˆ°èµ„æº  static final int PROPAGATE = -3; /* å½“å‰èŠ‚ç‚¹çŠ¶æ€ï¼Œé»˜è®¤æ˜¯0.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/locks/LockSupport/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/locks/LockSupport/</guid>
      <description>LockSupport  zh java.util.concurrent.locks.LockSupport å®˜æ–¹æ–‡æ¡£çš„æè¿°ä¹Ÿå¾ˆæ¸…æ¥š
  LockSupport æ˜¯åŸºäº sun.misc.Unsafe å°è£…çš„ çº¿ç¨‹é˜»å¡å·¥å…·ç±» ä¸»è¦æä¾› park å’Œ unpark ï¼Œå³ é˜»å¡ å’Œ è§£é™¤é˜»å¡ ä¸¤ç±»åŠŸèƒ½ ç±»ä¼¼äº Object çš„ wait å’Œ notify ï¼Œä½†æ˜¯ä¸éœ€è¦è·å– é”å¯¹è±¡ï¼Œä¹Ÿä¸ä¼šæŠ›å‡ºä¸­æ–­å¼‚å¸¸ ç±»ä¼¼äº Thread çš„ suspend å’Œ resume è¿‡æ—¶æ–¹æ³•ï¼Œä¸ä¼šæœ‰äº§ç”Ÿæ­»é”çš„å‰¯ä½œç”¨ park å’Œ unpark å¯ä»¥ç†è§£ä¸º æ“ä½œçº¿ç¨‹çš„è®¸å¯æ ‡ç¤ºï¼ˆtrue:è®¸å¯ / false:ä¸è®¸å¯ï¼‰  ä¸€ä¸ªçº¿ç¨‹åªæœ‰ä¸€ä¸ªè®¸å¯ï¼Œé»˜è®¤æ˜¯ falseï¼Œè°ƒç”¨ park ç›´æ¥é˜»å¡ å‡å¦‚å…ˆè°ƒåŠ¨ unpark ï¼Œåˆ™çº¿ç¨‹çš„è®¸å¯ä¸º trueï¼Œè°ƒç”¨ park ç›´æ¥è¿”å›ï¼Œä¸é˜»å¡ å› ä¸ºä¸€ä¸ªçº¿ç¨‹åªæœ‰ä¸€ä¸ªè®¸å¯ï¼Œè°ƒç”¨å¤šæ¬¡ unpark ä¸1æ¬¡çš„æ•ˆæœæ˜¯ä¸€æ · å‡å¦‚ä¸€å¼€å§‹æ²¡æœ‰ è®¸å¯ï¼Œè°ƒç”¨ park é˜»å¡ï¼Œéœ€è¦è°ƒç”¨ unpark ç»™äºˆè®¸å¯é€šè¡Œï¼Œè§£é™¤é˜»å¡ è§£é™¤é€šè¡Œ park é€šè¿‡å è®¸å¯åˆå˜ä¸º ç¦æ­¢ï¼Œä¸‹æ¬¡ park æ›¾ç„¶é˜»å¡   ä¸€äº›ç¤ºä¾‹ // å‡å¦‚å…ˆè°ƒåŠ¨ unpark ï¼Œåˆ™çº¿ç¨‹çš„è®¸å¯ä¸º trueï¼Œè°ƒç”¨ park ç›´æ¥è¿”å›ï¼Œä¸é˜»å¡ { LockSupport.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/locks/ReentrantLock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/locks/ReentrantLock/</guid>
      <description>ReentrantLock å®ç°åŸç† Sync // åŠ é” å’Œ é‡Šæ”¾çš„è¿‡ç¨‹ï¼Œéƒ½æ˜¯éƒ½ å¯¹ state(é‡å…¥æ¬¡æ•°) çš„ç»´æŠ¤ abstract static class Sync extends AbstractQueuedSynchronizer { abstract void lock(); // éå…¬å¹³é”çš„å®ç°  final boolean nonfairTryAcquire(int acquires) { final Thread current = Thread.currentThread(); int c = getState(); //ã€æŠ¢å é”ã€‘ ä¸º 0 æ—¶è¯´æ˜æ²¡æœ‰çº¿ç¨‹æŒæœ‰é”ï¼Œ  if (c == 0) { // CAS è‡ªæ—‹ç«äº‰  if (compareAndSetState(0, acquires)) { // æˆåŠŸåï¼Œç‹¬å çº¿ç¨‹è®¾ç½®ä¸ºè‡ªå·±  setExclusiveOwnerThread(current); return true; } } // ã€é‡å…¥é”ã€‘ä¸ä¸º 0 æ—¶åˆ¤æ–­ç‹¬å çº¿ç¨‹æ˜¯å¦è‡ªå·±ï¼Œ æ˜¯çš„è¯é‡å…¥  else if (current == getExclusiveOwnerThread()) { // é‡å…¥æ¬¡æ•° + 1  int nextc = c + acquires; if (nextc &amp;lt; 0) // overflow  throw new Error(&amp;#34;Maximum lock count exceeded&amp;#34;); setState(nextc); return true; } // ç«äº‰å¤±è´¥ï¼Œæ’é˜Ÿ  return false; } protected final boolean tryRelease(int releases) { // å‡å°‘é‡å…¥æ¬¡æ•°  int c = getState() - releases; if (Thread.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/locks/StampedLock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/locks/StampedLock/</guid>
      <description>StampedLock https://www.jianshu.com/p/4657ba18a0a0
https://www.liaoxuefeng.com/wiki/1252599548343744/1309138673991714
https://segmentfault.com/a/1190000015808032?utm_source=tag-newest
http://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/locks/StampedLock.html</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/Phaser/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/Phaser/</guid>
      <description> Phaser </description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/PriorityBlockingQueue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/PriorityBlockingQueue/</guid>
      <description>PriorityBlockingQueue  PriorityBlockingQueue æ˜¯ä¸€ä¸ªåŸºäºæ•°ç»„ çš„ æ— ç•Œ ä¼˜å…ˆçº§é˜Ÿåˆ— å› ä¸ºå¯ä»¥æ”¾æ— é™çš„å…ƒç´ ï¼Œæ‰€ä»¥ä¼šæ¶‰åŠåˆ°é˜Ÿåˆ—çš„æ‰©å®¹ é˜Ÿåˆ—å…ƒç´ æœ‰ä¼˜å…ˆçº§åŸºäº å †æ’åºï¼Œä¼˜å…ˆçº§é«˜çš„ä¼šæ”¾åœ¨å‰é¢ å…ƒç´ çš„ä¼˜å…ˆçº§æ¯”è¾ƒéœ€è¦è‡ªå®šä¹‰ Comparator ï¼Œæˆ–è€… å…ƒç´ è‡ªèº«æ˜¯ Comparable çš„ï¼Œå¦åˆ™ä¼šæŠ›å‡ºå¼‚å¸¸  java.lang.ClassCastException: xxx.xxx.Xxx cannot be cast to java.lang.Comparable   å®ç°åŸç† put public void put(E e) { // æ— ç•Œé˜Ÿåˆ—ï¼Œ put ä¸ä¼š é˜»å¡  offer(e); // never need to block } offer public boolean offer(E e) { if (e == null) throw new NullPointerException(); final ReentrantLock lock = this.lock; lock.lock(); int n, cap; Object[] array; // å…ƒç´ ä¸ªæ•° &amp;gt;= ç°æœ‰é˜Ÿåˆ—çš„é•¿åº¦  while ((n = size) &amp;gt;= (cap = (array = queue).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/Semaphore/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/Semaphore/</guid>
      <description>Semaphore Semaphoreç»´æŠ¤äº†ä¸€ä¸ª ä¿¡å·é‡è®¸å¯é›†ï¼Œé€šè¿‡ acquire æ¶ˆè€—ä¿¡å·é‡ï¼Œrelease å¢åŠ ä¿¡å·é‡ï¼Œå¦‚æœ acquire è·å–ä¿¡å·é‡çš„æ—¶å€™ ä¿¡å·é‡é›†åˆä¸­æ²¡æœ‰ï¼Œå°± park é˜»å¡ç­‰åˆ°ã€‚
å¦‚ä½•ä½¿ç”¨ int permits = 10; // åˆšå¼€å§‹æ²¡æœ‰è®¸å¯ Semaphore semaphore = new Semaphore(0); new Thread(() -&amp;gt; { for (int i = 0; i &amp;lt; permits; i++) { ThreadUtil.sleep(1, TimeUnit.SECONDS); // å¶æ•°é‡Šæ”¾ 1ä¸ªï¼Œå¥‡æ•°é‡Šæ”¾ 2ä¸ª  semaphore.release(i % 2 + 1); } }).start(); for (int i = 0; i &amp;lt; permits; i++) { semaphore.acquire(); // è·å–è®¸å¯åæ‰§è¡Œ  new Thread(() -&amp;gt; Tool.println(Thread.currentThread().getName() + &amp;#34;é€šè¿‡&amp;#34;)).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/SynchronousQueue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/SynchronousQueue/</guid>
      <description>SynchronousQueue SynchronousQueue æ˜¯ä¸€ä¸ª æ²¡æœ‰é•¿åº¦ çš„é˜»å¡é˜Ÿåˆ—ï¼Œå…¨ç¨‹æ— é”ï¼Œå…¨éƒ¨åŸºäº CAS
æ¯ä¸ªæ’å…¥æ“ä½œå¿…é¡»ç­‰å¾…å¦ä¸€ä¸ªçº¿ç¨‹çš„å¯¹åº”ç§»é™¤æ“ä½œï¼Œå³ put æ“ä½œä¼šé˜»å¡ï¼Œç›´åˆ°å…¶ä»–çº¿ç¨‹ takeã€‚é€‚ç”¨åœºæ™¯ï¼š
 é’ˆå¯¹ä¸€ä¸ªæ•°æ®å˜åŒ–çš„é€šçŸ¥ ç”Ÿäº§ä¸€ä¸ªæ•°æ®ï¼Œæ¶ˆè´¹ä¸€ä¸ªæ•°æ® &amp;hellip;  å¦‚ä½•ä½¿ç”¨ SynchronousQueue&amp;lt;Integer&amp;gt; sync = new SynchronousQueue&amp;lt;&amp;gt;(); final int[] someData = new int[1]; Consumer&amp;lt;Integer&amp;gt; changeIt = (newData) -&amp;gt; someData[0] = newData; Supplier&amp;lt;Integer&amp;gt; getChange = () -&amp;gt; someData[0]; //////////////////////////////// new Thread(() -&amp;gt; { for (; ; ) { final int newData = Math.abs(new Random().nextInt() % 100); changeIt.accept(newData); try { Tool.println(&amp;#34;æˆ‘å˜äº† &amp;#34; + newData); // è¿™é‡Œä¼š parkï¼Œç›´åˆ° sync.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/sun.misc/Unsafe/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/sun.misc/Unsafe/</guid>
      <description>Unsafe Unsafe æ˜¯ Java ä¸­å¯ä»¥ç›´æ¥æ“ä½œå†…å­˜çš„å·¥å…·ï¼Œå±äº sun.* åŒ…ä¸‹çš„APIã€‚
 ç›´æ¥æ“ä½œå†…å­˜æ˜¯å¾ˆå±é™©çš„ä¸€ä»¶äº‹ï¼Œä¸èƒ½é€šè¿‡Javaè™šæ‹Ÿæœºçš„åƒåœ¾å›æ”¶æœºåˆ¶è¿›è¡Œå†…å­˜é‡Šæ”¾ï¼Œåœ¨ä½¿ç”¨çš„æ—¶å€™éœ€è¦æ³¨æ„å†…å­˜æ³„æ¼å’Œæº¢å‡ºï¼Œå¹¶ä¸”Unsafeæ˜¯ä¸€ä¸ªå¹³å°ç›¸å…³çš„ç±»ï¼Œåœ¨å®é™…å¼€å‘ä¸­å»ºè®®ä¸è¦ç›´æ¥ä½¿ç”¨ã€‚
 è·å– Unsafe ç±»å®ä¾‹ JDK å¯¹è¿™ä¸ªç±»è¿›è¡Œäº†é™åˆ¶ï¼Œæˆ‘ä»¬ä¸èƒ½é€šè¿‡å¸¸è§„ new çš„æ–¹å¼å»è·å–è¯¥ç±»çš„å®ä¾‹ï¼Œä¹Ÿä¸èƒ½é€šè¿‡Unsafe.getUnsafe()è·å–
public final class Unsafe { private static final Unsafe theUnsafe; ... // ç§æœ‰æ„é€ æ–¹æ³•  private Unsafe() { } // ä¸æ˜¯ ç³»ç»Ÿ ClassLoader ä¼š æŠ›å‡º SecurityException å¼‚å¸¸  public static Unsafe getUnsafe() { Class var0 = Reflection.getCallerClass(); if (!VM.isSystemDomainLoader(var0.getClassLoader())) { throw new SecurityException(&amp;#34;Unsafe&amp;#34;); } else { return theUnsafe; } } static { ... // ä½†æ˜¯é™æ€ä»£ç å—åœ¨ ç±»åŠ è½½å ä¼šåœ¨å†…éƒ¨å®ä¾‹åŒ– è‡ªå·±  theUnsafe = new Unsafe(); .</description>
    </item>
    
  </channel>
</rss>