<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java-Concurrent Introduction on Java-Concurrent</title>
    <link>https://hello-world-example.github.io/Java-Concurrent/</link>
    <description>Recent content in Java-Concurrent Introduction on Java-Concurrent</description>
    <generator>Hugo -- gohugo.io</generator>
    
	<atom:link href="https://hello-world-example.github.io/Java-Concurrent/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/_sidebar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/_sidebar/</guid>
      <description> java.lang  Thread ThreadLocal  sun.misc  Unsafe  java.util.concurrent.locks  LockSupport AbstractQueuedSynchronizer ReentrantLock  java.util.concurrent  ExecutorService Future ForkJoinPool CompletableFuture CountDownLatch CyclicBarrier Phaser Semaphore  java.util.concurrent.atomic  AtomicLong LongAdder   </description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.lang/Thread/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.lang/Thread/</guid>
      <description>Thread 线程状态  @see java.lang.Thread.State
  NEW 至今尚未启动的线程处于这种状态，new Thread RUNNABLE 正在 Java 虚拟机中执行的线程处于这种状态，new Thread().start() BLOCKED 受阻塞并等待某个监视器锁的线程处于这种状态，synchronized(lock){} WAITING 无限期地等待另一个线程来执行某一特定操作的线程处于这种状态，synchronized(lock){ lock.wait() } TIMED_WAITING 等待另一个线程来执行取决于指定等待时间的操作的线程处于这种状态，，synchronized(lock){ lock.wait(timeout) } 、Thread.sleep(timeout) TERMINATED 线程执行结束  Methods 简介 thread.join() 等待线程执行完毕，再向下执行，与主线程的关系变成 串行执行。
final Thread thread = new Thread(() -&amp;gt; System.out.println(System.currentTimeMillis())); thread.start(); // 等待 thread 线程执行完毕， 再执行下面的代码 thread.join(); System.out.println(&amp;#34;Main 方法结束&amp;#34;); Thread.yield() 使 当前 线程从执行状态 变为 就绪状态，CPU 重新从众多 就绪状态 的线程里选择，包括当前线程。
 优先级高的不是一定被执行 当前线程不是已经不被执行 所有 就绪状态的线程，都有可能被执行 情况取决于 CPU 的选择，结果是随机的  thread.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.lang/ThreadLocal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.lang/ThreadLocal/</guid>
      <description>ThreadLoad 简介  ThreadLocal 实例通常是类中的 private static final 字段 数据 每个线程维护一份，通过隔离、避免竞争 线程池中每个线程是共享的，使用完需要清除，否则下次的线程使用者会使用到上次使用者设置的数据 个人感觉 数据是由 Thread 自己维护的，ThreadLocal 只是给我们提供了操作 Thread 内部变量的工具  ThreadLocal 代码片段 ThreadLocalMap getMap(Thread t) { return t.threadLocals; } // key: ThreadLocal ; vlaue: 是存储的数据 void createMap(Thread t, T firstValue) { t.threadLocals = new ThreadLocalMap(this, firstValue); } public T get() { // native 方法，返回当前线程对象  Thread t = Thread.currentThread(); // 获取线程（Thread）的 threadLocals 变量，类型是 ThreadLocal.ThreadLocalMap  ThreadLocalMap map = getMap(t); // 刚创建出来的 线程（Thread）维护的 threadLocals 变量是 null  if (map !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/atomic/AtomicLong/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/atomic/AtomicLong/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/atomic/LongAdder/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/atomic/LongAdder/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/CompletableFuture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/CompletableFuture/</guid>
      <description> CompletableFuture https://www.jianshu.com/p/b3c4dd85901e
Read More  强大的 CompletableFuture  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/CountDownLatch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/CountDownLatch/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/CyclicBarrier/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/CyclicBarrier/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/ExecutorService/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/ExecutorService/</guid>
      <description>ExecutorService   java.util.concurrent.ExecutorService java.util.concurrent.ThreadPoolExecutor   继承关系 - Executor (java.util.concurrent) - ❤5❤ ExecutorService (java.util.concurrent) - AbstractExecutorService (java.util.concurrent) - ❤5❤ ThreadPoolExecutor (java.util.concurrent) - ❤5❤ ScheduledThreadPoolExecutor (java.util.concurrent) - ❤7❤ ForkJoinPool (java.util.concurrent) - ScheduledExecutorService (java.util.concurrent) - ScheduledThreadPoolExecutor (java.util.concurrent)  ThreadPoolExecutor ThreadPoolExecutor 的构造参数如下
/** * @param corePoolSize 最小线程数 * @param maximumPoolSize 最大线程数 * @param keepAliveTime corePoolSize 到 maximumPoolSize 线程的空闲时间，超过该时间会被释放 * @param unit 参数 keepAliveTime 的单位 * @param workQueue 在任务执行之前保存进该队列 * @param threadFactory 线程工厂，主要给线程器名字，❤ 默认：Executors.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/ForkJoinPool/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/ForkJoinPool/</guid>
      <description>ForkJoinPool https://www.cnblogs.com/mxh-java/p/12244318.html</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/Future/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/Future/</guid>
      <description>Future  en java.util.concurrent.Future
zh java.util.concurrent.Future
 Future 接口 public interface Future&amp;lt;V&amp;gt; { // 等待任务结束，获取结果  V get() throws InterruptedException, ExecutionException; // 获取结果，设置超时时间  V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; // 取消任务的执行  boolean cancel(boolean mayInterruptIfRunning); // 正常完成前取消，返回 true  boolean isCancelled(); // 任务正常终止、异常或取消，返回true  boolean isDone(); } 继承关系  Future (java.util.concurrent)  RunnableFuture (java.util.concurrent)  FutureTask (java.util.concurrent)  ForkJoinTask (java.util.concurrent) CompletableFuture (java.util.concurrent) &amp;hellip;   缺点 虽然 JDK5 新增的 Future 用于描述一个异步计算的结果，但是对于结果的获取却是很不方便，只能通过 阻塞 或者 轮询 的方式得到任务的结果。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/locks/AbstractQueuedSynchronizer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/locks/AbstractQueuedSynchronizer/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/locks/LockSupport/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/locks/LockSupport/</guid>
      <description>LockSupport  zh java.util.concurrent.locks.LockSupport 官方文档的描述也很清楚
  LockSupport 是基于 sun.misc.Unsafe 封装的 线程阻塞工具类 主要提供 park 和 unpark ，即 阻塞 和 解除阻塞 两类功能 类似于 Object 的 wait 和 notify ，但是不需要获取 锁对象，也不会抛出中断异常 类似于 Thread 的 suspend 和 resume 过时方法，不会有产生死锁的副作用 park 和 unpark 可以理解为 操作线程的许可标示（true:许可 / false:不许可）  一个线程只有一个许可，默认是 false，调用 park 直接阻塞 假如先调动 unpark ，则线程的许可为 true，调用 park 直接返回，不阻塞 因为一个线程只有一个许可，调用多次 unpark 与1次的效果是一样 假如一开始没有 许可，调用 park 阻塞，需要调用 unpark 给予许可同行，解除阻塞 解除同行后 许可 变为 禁止，下次 park 曾然阻塞   一些示例 // 假如先调动 unpark ，则线程的许可为 true，调用 park 直接返回，不阻塞 { LockSupport.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/locks/ReentrantLock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/locks/ReentrantLock/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/Phaser/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/Phaser/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/Semaphore/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/Semaphore/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/sun.misc/Unsafe/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/sun.misc/Unsafe/</guid>
      <description>Unsafe Unsafe 是 Java 中可以直接操作内存的工具，属于 sun.* 包下的API。
 直接操作内存是很危险的一件事，不能通过Java虚拟机的垃圾回收机制进行内存释放，在使用的时候需要注意内存泄漏和溢出，并且Unsafe是一个平台相关的类，在实际开发中建议不要直接使用。
 获取 Unsafe 类实例 JDK 对这个类进行了限制，我们不能通过常规 new 的方式去获取该类的实例，也不能通过Unsafe.getUnsafe()获取
public final class Unsafe { private static final Unsafe theUnsafe; ... // 私有构造方法  private Unsafe() { } // 不是 系统 ClassLoader 会 抛出 SecurityException 异常  public static Unsafe getUnsafe() { Class var0 = Reflection.getCallerClass(); if (!VM.isSystemDomainLoader(var0.getClassLoader())) { throw new SecurityException(&amp;#34;Unsafe&amp;#34;); } else { return theUnsafe; } } static { ... // 但是静态代码块在 类加载后 会在内部实例化 自己  theUnsafe = new Unsafe(); .</description>
    </item>
    
  </channel>
</rss>