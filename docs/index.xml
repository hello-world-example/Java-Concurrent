<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java-Concurrent Introduction on Java-Concurrent</title>
    <link>https://hello-world-example.github.io/Java-Concurrent/</link>
    <description>Recent content in Java-Concurrent Introduction on Java-Concurrent</description>
    <generator>Hugo -- gohugo.io</generator>
    
	<atom:link href="https://hello-world-example.github.io/Java-Concurrent/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/_sidebar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/_sidebar/</guid>
      <description> java.lang  Thread ThreadLocal  sun.misc  Unsafe  java.util.concurrent.locks  LockSupport AbstractQueuedSynchronizer ReentrantLock [8]StampedLock  java.util.concurrent  ExecutorService Future [7]ForkJoin [8]CompletableFuture CountDownLatch CyclicBarrier Phaser Semaphore  java.util.concurrent.atomic  AtomicLong [8]LongAdder   </description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.lang/Thread/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.lang/Thread/</guid>
      <description>Thread 线程状态  @see java.lang.Thread.State
  NEW 至今尚未启动的线程处于这种状态，new Thread RUNNABLE 正在 Java 虚拟机中执行的线程处于这种状态，new Thread().start() BLOCKED 受阻塞并等待某个监视器锁的线程处于这种状态，synchronized(lock){} WAITING 无限期地等待另一个线程来执行某一特定操作的线程处于这种状态，synchronized(lock){ lock.wait() } TIMED_WAITING 等待另一个线程来执行取决于指定等待时间的操作的线程处于这种状态，，synchronized(lock){ lock.wait(timeout) } 、Thread.sleep(timeout) TERMINATED 线程执行结束  Methods 简介 thread.join() 等待线程执行完毕，再向下执行，与主线程的关系变成 串行执行。
final Thread thread = new Thread(() -&amp;gt; System.out.println(System.currentTimeMillis())); thread.start(); // 等待 thread 线程执行完毕， 再执行下面的代码 thread.join(); System.out.println(&amp;#34;Main 方法结束&amp;#34;); Thread.yield() 使 当前 线程从执行状态 变为 就绪状态，CPU 重新从众多 就绪状态 的线程里选择，包括当前线程。
 优先级高的不是一定被执行 当前线程不是已经不被执行 所有 就绪状态的线程，都有可能被执行 情况取决于 CPU 的选择，结果是随机的  thread.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.lang/ThreadLocal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.lang/ThreadLocal/</guid>
      <description>ThreadLoad 简介  ThreadLocal 实例通常是类中的 private static final 字段 数据 每个线程维护一份，通过隔离、避免竞争 线程池中每个线程是共享的，使用完需要清除，否则下次的线程使用者会使用到上次使用者设置的数据 个人感觉 数据是由 Thread 自己维护的，ThreadLocal 只是给我们提供了操作 Thread 内部变量的工具  ThreadLocal 代码片段 ThreadLocalMap getMap(Thread t) { return t.threadLocals; } // key: ThreadLocal ; vlaue: 是存储的数据 void createMap(Thread t, T firstValue) { t.threadLocals = new ThreadLocalMap(this, firstValue); } public T get() { // native 方法，返回当前线程对象  Thread t = Thread.currentThread(); // 获取线程（Thread）的 threadLocals 变量，类型是 ThreadLocal.ThreadLocalMap  ThreadLocalMap map = getMap(t); // 刚创建出来的 线程（Thread）维护的 threadLocals 变量是 null  if (map !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/atomic/AtomicLong/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/atomic/AtomicLong/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/atomic/LongAdder/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/atomic/LongAdder/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/CompletableFuture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/CompletableFuture/</guid>
      <description> CompletableFuture https://www.jianshu.com/p/b3c4dd85901e
Read More  强大的 CompletableFuture  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/CountDownLatch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/CountDownLatch/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/CyclicBarrier/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/CyclicBarrier/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/ExecutorService/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/ExecutorService/</guid>
      <description>ExecutorService   java.util.concurrent.ExecutorService java.util.concurrent.ThreadPoolExecutor   继承关系 - Executor (java.util.concurrent) - ❤5❤ ExecutorService (java.util.concurrent) - AbstractExecutorService (java.util.concurrent) - ❤5❤ ThreadPoolExecutor (java.util.concurrent) - ❤5❤ ScheduledThreadPoolExecutor (java.util.concurrent) - ❤7❤ ForkJoinPool (java.util.concurrent) - ScheduledExecutorService (java.util.concurrent) - ScheduledThreadPoolExecutor (java.util.concurrent)  ThreadPoolExecutor ThreadPoolExecutor 的构造参数如下
/** * @param corePoolSize 最小线程数 * @param maximumPoolSize 最大线程数 * @param keepAliveTime corePoolSize 到 maximumPoolSize 线程的空闲时间，超过该时间会被释放 * @param unit 参数 keepAliveTime 的单位 * @param workQueue 在任务执行之前保存进该队列 * @param threadFactory 线程工厂，主要给线程器名字，❤ 默认：Executors.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/ForkJoin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/ForkJoin/</guid>
      <description>ForkJoin ForkJoin 是一个 基于分而治之算法， 把大任务分割成若干个小任务，最终汇总每个小任务结果后，得到大任务结果的框架。框架基于以下两种操作：
 fork 操作：把任务分成更小的任务，使用这个框架执行它们 join 操作：等待创建的任务的计算结束  与 Executor 的区别  Executor 是所有工作线程公用一个任务队列，所有的线程消费一个任务队列里面的任务 ForkJoin 是 每个线程都有一个任务对象，每个线程消费各自任务队列的任务   这样的话， ForkJoin 可能会导致一个问题，假如有些任务队列早早被消费完了，则该队列对应的线程就闲置了 Executor 则不会出现该问题，因为只有一个队列，当线程执行完一个任务后，重新从队列中获取任务，直到所有的任务执行换才会闲置   ForkJoin 为了解决任务队列消费速度不一致导致的闲置问题，当一个任务队列执行完之后，就去其他线程的队列里窃取一个任务来执行，还给这个行为起了一个高大上的名字：工作窃取（work-stealing）算法。JDK 1.8 可以简单的通过 ExecutorService executor = Executors.newWorkStealingPool(4) 获取改类型的 Executor 解决了线程闲置问题， Executor 和 ForkJoin 的线程都可达到满负荷运行了，这时候的区别在于两者对数据的竞争状态不一样  Executor 始终都是所有的线程竞争一个队列的数据 ForkJoin 只有在 “窃取” 其他线程任务队里的最后一条数据的时候才产生竞争   核心类  ForkJoinPool：它实现 ExecutorService 接口 和 work-stealing 算法，管理工作线程和提供关于任务的状态和执行的信息 ForkJoinTask： 它是是在 ForkJoinPool 中执行的任务的基类，提供在任务中执行 fork() 和 join() 操作的机制。通常， 为了实现你的 Fork/Join 任务，需要实现 ForkJoinTask 的子类  RecursiveAction 处理没有返回值的任务 RecursiveTask 处理有返回值的任务   编程流程 一个使用 ForkJoin 框架累加的示例</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/Future/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/Future/</guid>
      <description>Future  en java.util.concurrent.Future
zh java.util.concurrent.Future
 Future 接口 Future 接口是对异步行为的抽象，用来表示异步计算的结果，接口比较简单，如下：
public interface Future&amp;lt;V&amp;gt; { // 等待任务结束，获取结果  V get() throws InterruptedException, ExecutionException; // 获取结果，设置超时时间  V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; // 取消任务的执行  boolean cancel(boolean mayInterruptIfRunning); // 正常完成前取消，返回 true  boolean isCancelled(); // 任务正常终止、异常或取消，返回true  boolean isDone(); } 继承关系  Future (java.util.concurrent)  RunnableFuture (java.util.concurrent) extends Runnable  FutureTask (java.util.concurrent)  ForkJoinTask (java.util.concurrent) CompletableFuture (java.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/locks/AbstractQueuedSynchronizer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/locks/AbstractQueuedSynchronizer/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/locks/LockSupport/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/locks/LockSupport/</guid>
      <description>LockSupport  zh java.util.concurrent.locks.LockSupport 官方文档的描述也很清楚
  LockSupport 是基于 sun.misc.Unsafe 封装的 线程阻塞工具类 主要提供 park 和 unpark ，即 阻塞 和 解除阻塞 两类功能 类似于 Object 的 wait 和 notify ，但是不需要获取 锁对象，也不会抛出中断异常 类似于 Thread 的 suspend 和 resume 过时方法，不会有产生死锁的副作用 park 和 unpark 可以理解为 操作线程的许可标示（true:许可 / false:不许可）  一个线程只有一个许可，默认是 false，调用 park 直接阻塞 假如先调动 unpark ，则线程的许可为 true，调用 park 直接返回，不阻塞 因为一个线程只有一个许可，调用多次 unpark 与1次的效果是一样 假如一开始没有 许可，调用 park 阻塞，需要调用 unpark 给予许可通行，解除阻塞 解除通行 park 通过后 许可又变为 禁止，下次 park 曾然阻塞   一些示例 // 假如先调动 unpark ，则线程的许可为 true，调用 park 直接返回，不阻塞 { LockSupport.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/locks/ReentrantLock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/locks/ReentrantLock/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/locks/StampedLock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/locks/StampedLock/</guid>
      <description>StampedLock https://www.jianshu.com/p/4657ba18a0a0
https://www.liaoxuefeng.com/wiki/1252599548343744/1309138673991714
https://segmentfault.com/a/1190000015808032?utm_source=tag-newest
http://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/locks/StampedLock.html</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/Phaser/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/Phaser/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/Semaphore/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/Semaphore/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/sun.misc/Unsafe/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/sun.misc/Unsafe/</guid>
      <description>Unsafe Unsafe 是 Java 中可以直接操作内存的工具，属于 sun.* 包下的API。
 直接操作内存是很危险的一件事，不能通过Java虚拟机的垃圾回收机制进行内存释放，在使用的时候需要注意内存泄漏和溢出，并且Unsafe是一个平台相关的类，在实际开发中建议不要直接使用。
 获取 Unsafe 类实例 JDK 对这个类进行了限制，我们不能通过常规 new 的方式去获取该类的实例，也不能通过Unsafe.getUnsafe()获取
public final class Unsafe { private static final Unsafe theUnsafe; ... // 私有构造方法  private Unsafe() { } // 不是 系统 ClassLoader 会 抛出 SecurityException 异常  public static Unsafe getUnsafe() { Class var0 = Reflection.getCallerClass(); if (!VM.isSystemDomainLoader(var0.getClassLoader())) { throw new SecurityException(&amp;#34;Unsafe&amp;#34;); } else { return theUnsafe; } } static { ... // 但是静态代码块在 类加载后 会在内部实例化 自己  theUnsafe = new Unsafe(); .</description>
    </item>
    
  </channel>
</rss>