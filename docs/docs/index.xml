<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docs on Java-Concurrent</title>
    <link>https://hello-world-example.github.io/Java-Concurrent/docs/</link>
    <description>Recent content in Docs on Java-Concurrent</description>
    <generator>Hugo -- gohugo.io</generator>
    
	<atom:link href="https://hello-world-example.github.io/Java-Concurrent/docs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.lang/Thread/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.lang/Thread/</guid>
      <description>Thread 线程状态  @see java.lang.Thread.State
  NEW 至今尚未启动的线程处于这种状态，new Thread RUNNABLE 正在 Java 虚拟机中执行的线程处于这种状态，new Thread().start() BLOCKED 受阻塞并等待某个监视器锁的线程处于这种状态，synchronized(lock){} WAITING 无限期地等待另一个线程来执行某一特定操作的线程处于这种状态，synchronized(lock){ lock.wait() } TIMED_WAITING 等待另一个线程来执行取决于指定等待时间的操作的线程处于这种状态，，synchronized(lock){ lock.wait(timeout) } 、Thread.sleep(timeout) TERMINATED 线程执行结束  Methods 简介 thread.join() 等待线程执行完毕，再向下执行，与主线程的关系变成 串行执行。
final Thread thread = new Thread(() -&amp;gt; System.out.println(System.currentTimeMillis())); thread.start(); // 等待 thread 线程执行完毕， 再执行下面的代码 thread.join(); System.out.println(&amp;#34;Main 方法结束&amp;#34;); Thread.yield() 使 当前 线程从执行状态 变为 就绪状态，CPU 重新从众多 就绪状态 的线程里选择，包括当前线程。
 优先级高的不是一定被执行 当前线程不是已经不被执行 所有 就绪状态的线程，都有可能被执行 情况取决于 CPU 的选择，结果是随机的  thread.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.lang/ThreadLocal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.lang/ThreadLocal/</guid>
      <description>ThreadLoad 简介  ThreadLocal 实例通常是类中的 private static final 字段 数据 每个线程维护一份，通过隔离、避免竞争 线程池中每个线程是共享的，使用完需要清除，否则下次的线程使用者会使用到上次使用者设置的数据 个人感觉 数据是由 Thread 自己维护的，ThreadLocal 只是给我们提供了操作 Thread 内部变量的工具  ThreadLocal 代码片段 ThreadLocalMap getMap(Thread t) { return t.threadLocals; } // key: ThreadLocal ; vlaue: 是存储的数据 void createMap(Thread t, T firstValue) { t.threadLocals = new ThreadLocalMap(this, firstValue); } public T get() { // native 方法，返回当前线程对象  Thread t = Thread.currentThread(); // 获取线程（Thread）的 threadLocals 变量，类型是 ThreadLocal.ThreadLocalMap  ThreadLocalMap map = getMap(t); // 刚创建出来的 线程（Thread）维护的 threadLocals 变量是 null  if (map !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/atomic/AtomicLong/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/atomic/AtomicLong/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/atomic/LongAdder/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/atomic/LongAdder/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/CompletableFuture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/CompletableFuture/</guid>
      <description> CompletableFuture Read More  强大的 CompletableFuture  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/CountDownLatch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/CountDownLatch/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/CyclicBarrier/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/CyclicBarrier/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/ExecutorService/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/ExecutorService/</guid>
      <description>ExecutorService   java.util.concurrent.ExecutorService java.util.concurrent.ThreadPoolExecutor   继承关系 - Executor (java.util.concurrent) - ❤5❤ ExecutorService (java.util.concurrent) - AbstractExecutorService (java.util.concurrent) - ❤5❤ ThreadPoolExecutor (java.util.concurrent) - ❤5❤ ScheduledThreadPoolExecutor (java.util.concurrent) - ❤7❤ ForkJoinPool (java.util.concurrent) - ScheduledExecutorService (java.util.concurrent) - ScheduledThreadPoolExecutor (java.util.concurrent)  ThreadPoolExecutor ThreadPoolExecutor 的构造参数如下
/** * @param corePoolSize 最小线程数 * @param maximumPoolSize 最大线程数 * @param keepAliveTime corePoolSize 到 maximumPoolSize 线程的空闲时间，超过该时间会被释放 * @param unit 参数 keepAliveTime 的单位 * @param workQueue 在任务执行之前保存进该队列 * @param threadFactory 线程工厂，主要给线程器名字，❤ 默认：Executors.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/ForkJoinPool/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/ForkJoinPool/</guid>
      <description> ForkJoinPool </description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/Future/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/Future/</guid>
      <description> Future  en java.util.concurrent.Future
zh java.util.concurrent.Future
 Future 接口 public interface Future&amp;lt;V&amp;gt; { boolean isDone(); V get() throws InterruptedException, ExecutionException; V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; boolean cancel(boolean mayInterruptIfRunning); boolean isCancelled(); } 缺点 虽然 JDK5 新增的 Future 用于描述一个异步计算的结果，但是对于结果的获取却是很不方便，只能通过 阻塞 或者 轮询 的方式得到任务的结果。
 阻塞的方式显然和我们的异步编程的初衷相违背 轮询的方式又会耗费无谓的 CPU 资源，而且也不能及时地得到计算结果  改进方案  Guava ListenableFuture JDK8 CompletableFuture  Read More  从 Java Future 到 Guava ListenableFuture 实现异步调用  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/locks/AbstractQueuedSynchronizer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/locks/AbstractQueuedSynchronizer/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/locks/ReentrantLock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/locks/ReentrantLock/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/Phaser/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/Phaser/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/Semaphore/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-Concurrent/docs/java.util.concurrent/Semaphore/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>